---
title: Java编程思想 第14章 类型信息
date: 2017-11-29 23:23:32
tags: [读书笔记, Java编程思想]
---
> 运行时类型信息使得你可以在程序运行时发现和使用类型信息。
<!--more-->
## 为什么需要RTTI(RunTime Type Identification)

当从基类匿名引用容器中取出元素，这种容器——实际上它将所有的事物都当做Object持有——会自动将结果转型回基类。这是RTTI最基本的使用形式，因为在Java中，所有的类型转换都是在运行时进行正确性检查的。这也是RTTI名字的含义：在运行时，识别一个对象的类型。

但是RTTI类型转换并不彻底，只能从Object转型为基类，而不是基类的导出类。这是因为通过容器和泛型机制来保证的，但是实际的基类引用调用的具体代码是由多态机制决定的。也可以通过RTTI查询具体的类型信息，然后选择或者提出特例。

## Class对象

要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由被称为Class对象的特殊对象完成的，它包含了与类有关的信息。事实上，Class对象就是用来创建类的所有的常规对象的。Java使用Class对象来执行其RTTI，即使正在执行的是类似转型这样的操作。Class类还拥有大量的使用RTTI的其他方式。

类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象，更恰当的说，是被保存在一个同名的.class的对象一样。为了生成这个类的对象，运行这个程序的Java虚拟机将使用被称为“类加载器”的子系统。

类加载器子系统实际上可以包含一条类加载链，但是只有一个原生类加载器，他是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，它们通常是从本地盘加载的。这条链中，通常不需要添加额外的类加载器，但是如有由特殊需求，比如以某种特殊的方式加载类，以支持Web服务器应用，或者在网络下载类，那么有一种方式可以挂接额外的类加载器。

所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。构造器也是类的静态方法。类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码。一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。

## 类型转换前先做检查

RTTI形式包括：

1. 传统的类型转换，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常。
2. 代表对象的类型的Class对象。通过查询Class对象可以获取运行时需要的信息。

## 注册工厂

使用工厂是设计模式，将对象的创建工作交给类自己去完成。工厂方法可以被多态地调用，从而创建恰当的对象。

## instanceof与Class的等价性

在查询类型信息时，以instanceof的形式与直接比较Class对象有一个很重要的差别。instanceof保持了类型的概念，它指的是“是这个类或者是这个类的派生类”，而如果用==比较则不包括派生类。

## 反射：运行时类的信息

如果不知道某个对象的确切类型，RTTI可以完成这种查询。但是有一个限制：这个类型在编译时必须已知，换句话说，在编译时，编译器必须知道所有要通过RTTI来处理的类。Class类与java.lang.reflect类库一起对放射的概念进行了支持，该类库包括了Filed、Method以及Constructor类。这些类型的对象时由JVM在运行时创建的，用来表示未知类里对应的成员。这样就可以使用Constructor创建新的对象，用get和set方法读取和修改与Field对下给你关联的字段，用invoke方法调用与Method对象关联的方法。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。

## 动态代理

代理时最基本的设计模式之一，是为了提供额外的或不同的操作，而插入的用来替代实际对象的对象。这些操作通常涉及与实际对象的通信，因此代理通常充当着中间人的角色。Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地处理对所有代理方法的调用。在动态代理上所做的所有的调用都会被重定向到单一的调用处理器上，它的工作时揭示调用的类型并确定相应的对策。

通过调用静态方法Proxy.newProxyInstance可以创建动态代理，这个方法需要得到一个类加载器，一个希望该代理实现的接口列表，以及接口的一个实现。动态代理可以将所有调用重定向调用代理器，因此通常会向调用处理器的构造器传递一个实际对象的引用，从而使得调用处理器在执行其中介任务时，可以将请求转发。

## 空对象

当使用内置的null表示缺少对象是，在每次使用引用时都必须测试其是否为null，问题在于null除了在试图用它执行任何操作来产生NullPointerExceptrion之外，它自己没有其他任何行为。引入空对象的思想将会很有用，它可以接受传递给它所代表的对象的消息，但是将返回表示为实际上并不存在任何真实的对象的值。通过这种方式，可以假设所有的对象都是有效的，而不必浪费编程精力去检查null。

## 接口与类型信息

interface关键字的一种重要目标就是允许程序员隔离构建，进而降低耦合性。虽然很多方法是私有的，但是也可以通过反射来到达并调用那些非公共访问权限的方法。对于域来说，的确如此，即便是private域。

## 总结

RTTI允许通过匿名基类的引用来发现类型信息。可以利用RTTI将代码组织成类似与面向过程的一系列switch语句。虽然多态机制很有效，但是使用多态机制的方法调用，要求拥有基类定义的控制权，所以需要使用RTTI来检查特定类型。