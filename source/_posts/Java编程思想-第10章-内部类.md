---
title: Java编程思想 第10章 内部类
date: 2017-11-25 21:23:56
tags: [读书笔记, Java编程思想]
---
> 可以将一个类的定义放在另一个类的定义内部，这就是内部类。

<!--more-->

## 创建内部类

创建内部类的方式就是把类的定义置于外围类的里面。如果想从外部类的非静态方法之外的任意位置创建内部类的对象，那么必须具体地指明这个对象的类型。

## 链接到外部类

内部类是一种名字隐藏和组织代码的模式。当生成一个内部类的对象时，此对象与制造它外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何条件。此外，内部类还拥有其外围类的所有元素的访问权。

## 使用.this和.new

如果要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受检查，因此没有任何运行时开销。

要想直接创建内部类的对象，必须使用外部类的对象来创建内部类对象。在new表达式中提供对其他外部类对象的引用，需要使用.new语法。

在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部类对象上。但是，如果创建的是嵌套类，那么它就不需要对外部类对象的引用。

## 内部类与向上转型

当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地，从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

## 在方法和作用域内的内部类

在一个方法里面或者任意的作用域内定义内部类。这么做有两个理由：

1. 如前所示，实现了某类型的接口，于是可以创建并返回对其的引用。
2. 想要解决一个复杂的问题，想创建一个类来辅助解决方案，但是又不希望这个类是公共可用的。

在后面的例子中(但是笔者不会把例子写上的)，先前的代码将被修改，以用来实现：

1. 一个定义在方法中的类。
2. 一个定义在作用域内的类，此作用域在方法的内部。
3. 一个实现了接口的匿名类。
4. 一个匿名类，它扩展了有非默认构造器的类。
5. 一个匿名类，它执行字段初始化。
6. 一个匿名类，它通过实例初始化实现构造(匿名类不可能有构造器)

## 匿名内部类

将返回值的生成与表示这个返回值的类的定义结合在一起，这个类是匿名的，它没有名字。如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制——不能重载实例初始化方法，所以仅有一个这样的构造器。

匿名内部类与正规的继承相比有些首先，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果实现接口也只能实现一个接口。

## 嵌套类

如果不需要内部类对象与其外围类对象之间的联系，那么可以将内部类声明为static。这通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时候，就不是这样了。嵌套类意味着：

1. 要创建嵌套类的对象，并不需要其外围类的对象。
2. 不能从嵌套类的对象中访问非静态的外围类对象。

嵌套类于普通的内部类的另外一个区别。普通内部类的字段于方法，只能放在类的外部层次，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。

## 为什么需要内部类

一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。

内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外围类实现这个接口有什么区别？但俺是：后者不是总能享受到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：

> 每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响。

如果没有内部类提供的、可以继承多个具体的或抽象的类的嫩里，一些实现合计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型。

- 闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。
- Java通过闭包来实现回调而不是指针，这比指针更加安全。
- 应用框架程序就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些特定方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案。

## 内部类的继承

因为内部类的构造器必须链接到外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外围类对象的秘密的引用必须被初始化，而在导出类中不再存在可连接的默认对象。要解决这个问题必须使用特殊的语法来明确说清它们之间的关联。但是当要生成一个构造器时，默认的构造器并不算好，而且布恩那个只是传递一个指向外围类对象的引用，此外，必须在构造器内部使用enclosingClassReference.super()语法。这样才提供了必要的引用，然后程序才能编译通过。

## 内部类可以被覆盖吗

覆盖内部类就好像它时外围类的一个方法，其实并不起什么作用。

## 局部内部类

前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。

## 内部类标识符

每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息，内部类也必须生成一个.clas文件以包含它们的Class对象信息。这些类文件的命名有严格的规则：外围类的名字，加上“$”，再加上内部类的名字。如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。 如果内部类是嵌套再别的内部类之中，只需要直接将它们的名字加在外围类标识符与$的后面。

虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是Java的标准命名方式，所以产生的文件自动都是平台无关的。

## 总结

比起面向对象编程中其他的概念来，接口和内部类更深奥复杂；比如C++就没有这些。将两者结合起来，同样能够解决C++中的用多重继承所能剞劂的问题。然而，多重继承再C++中被证明是相当难以使用的，相比较而言，Java的接口和内部类就容易理解多了。