---
title: Java编程思想 第15章 泛型
date: 2017-11-30 22:48:22
tags: [读书笔记, Java编程思想]
---
> 一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。
<!--more-->
## 与C++的比较

Java的泛型借鉴了C++模板，所以了解C++的模板有助于了解Java泛型的的基础，可以知道Java泛型的局限以及为什么会有这些局限。

## 简单泛型

促成泛型的出现最引人注目的一个原因就是为了创造容器类。与之前使用Object，要达到暂时不指定类型，而是稍后再决定具体使用什么类型的目的，需要使用类型参数，用尖括号括住。然后在使用这个类的时候，再用实际的类型替换此类型参数。

## 泛型接口

泛型也可以应用于接口。例如生成器，这是一种专门负责创建对象的类。实际上，这是工厂方法设计模式的一种应用。不过，当使用生成器创建对象时，它不需要任何参数，而工厂方法一般需要参数。也就是说，生成器无需额外的信息就知道如何创建新对象。

## 泛型方法

参数化方法可以用在泛型类或非泛型类，也就是说泛型方法与类没有关系。泛型方法使得该方法能够独立于类而产生变换。一个基本的指导原则：无论何时，应该尽量使用泛型方法。另外，对于一个static的方法而言，无法访问泛型类的类型参数，所以如果static方法需要使用范型能力，就必须使其称为泛型方法。要定义泛型方法，只需将泛型参数列表置于返回值之前。

## 匿名内部类

泛型还可以应用于内部类以及匿名内部类。

## 构建复杂模型

泛型的一个重要好处是能够简单而安全地创建复杂的模型。

## 擦除的神秘之处

在泛型代码内部，无法获得任何有关泛型参数类型的信息。因为泛型会被擦除为它们的原生类型。所以可以使用给定泛型类的边界，重用extends关键字，就可以指明擦除的边界。由于擦除的存在，所以在泛型方法中不能调用具体类的方法，除非指定了边界，这是编译前确定的。

## 擦除的补偿

餐厨丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作。偶尔可以绕过这些问题来编程，但有时必须通过引入类型标签来对擦除进行补偿。这意味着需要显示地传递类型的Class对象，一边可以在类型表达式这种使用。

## 边界

边界使得可以在用于泛型的参数类型上设置限制条件。尽管可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是可以按照自己的边界类型来调用方法。

## 通配符

通配符就是在泛型参数表达式中的问号。<? extends MyClass> 表示任何从MyClass继承的类型。<? super MyClass>表示超类型通配符，声明为MyClass的任何基类的界定。

## 问题

- 任何基本类型都不能作为类型参数
- 实现参数化接口：一个类不能实现同一个泛型接口的两种变体，这是由于擦除的原因，这两个变体会称为相同的接口。
- 转型和警告：使用带有泛型类型参数的转型或instanceof不会有任何效果。
- 重载：由于擦除的原因，重载方法将产生相同的类型签名
- 基类劫持了接口

## 自限定的类型

不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。这可以按照Jim Coplien在C++中的古怪的循环模板模式的命名方式，称为古怪的循环泛型(CRG)。

## 动态类型安全

因为可以向Java SE5之前的代码传递，所以旧式代码仍旧有可能破坏容器，Java SE5的java.util.Collections中有一组便利工具，可以解决在这种情况下的类型检查问题。

## 异常

由于擦除的原因，将泛型应用于异常是非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自Throwable。但是，类型参数可能会在一个方法的throws子句中用到。这使得可以编写随检查型异常的类型而发生变化的泛型代码。

## 混型

术语混型随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。

## 潜在类型机制

某些编程语言提供的一种解决方案称为潜在类型机制或结构化类型机制，而更古怪的术语称为鸭子类型机制。鸭子类型机制变成了一种相当流行的术语，可能是因为它不想其他的术语那样承载着历史的包袱。

## 对缺乏潜在类型机制的补偿

尽管Java不支持潜在类型机制，但是着并不意味着有界泛型代码不能在不同的类型层次结构之间应用。也就是说，仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。

## 将函数对象用作策略

使用策略设计模式，可以产生更优雅的代码。

## 总结

使用泛型类型机制的最吸引人的地方，就是使用容器类的地方。在Java SE5之前，将一个对象放置于容器中，这个对象就会向上转型为Object，而取回时要手动向下转型，有可能会导致错误的向下转型。产生例如“狗在猫的列表里”这种问题。