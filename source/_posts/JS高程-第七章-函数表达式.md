---
title: JS高程 第七章 函数表达式
date: 2017-10-20 23:02:55
tags: [读书笔记, JavaScript高级程序设计]
---
函数表达式是再JavaScript中是一个很强大的特性。前文中曾经提过，有两种定义函数的方式，函数声明与函数表达式。函数声明就是像正常定义一个函数的方式来声明一个函数，函数表达式方式则是将函数赋给一个变量，我们之前提过一个概念叫做函数声明提升，即解释器会将所有函数声明提到最前方，让函数再任意地方调用都没有问题，但是函数表达式的方式的方式则不会进行函数声明提升，这种方式创建的函数叫做匿名函数，因为function关键字之后没有函数名标识符。匿名函数也叫做lamda表达式。

<!--more-->

## 递归

递归函数就是函数不断调用自身来实现某种功能，比如求阶乘，斐波那契数列等。但是请看下列代码

```
function factorial(num) {
    if (num < 1>) {
        return 1;
    }
    return num*factorial(num-1);
}
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)) //出错!
```

在上面的例子中，首先定义了一个递归函数用来求阶乘，然后将函数赋给另外一个函数，将原函数释放，调用这个新函数，因为在递归函数内部必须调用原函数，但是原函数已经被释放，由此导致的错误，此时就可以使用callee方法解决这个问题。

```
function factorial(num) {
    if (num < 1>) {
        return 1;
    }
    return num*arguments.callee(num-1);
}
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)) //正常!
```

这样就避免了原函数被释放的问题，也可以使用另外一种方式。

```
var factorial = (function f(num) {
    if (num < 1>) {
        return 1;
    }
    return num*f(num-1);
})
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)) //正常!
```

上面这种方式也可以达到效果，但是这种方式实际上是引入了另外一个命名函数。

## 闭包

闭包是一个JavaScript程序员经常涉及到的概念，简单来说，闭包就是函数中返回一个函数，精确一点就是指有权访问另一个函数作用中的变量的函数，本质上还是函数。

闭包是利用作用域链来实现，当某个函数被创建时，会创建一个执行环境和一个作用域链，后台中每一个执行环境都有一个变量对象。保存当前执行环境中的所有活动变量。当推出当前环境，也就是函数推出后，这些活动变量就会被释放，但是调用闭包不会释放外部函数的活动变量，以此来保证对外部函数变量对象的访问。

> 因为闭包函数会保存自己以及外部函数的变量，所以会占用更多的内存。

### 闭包和变量

使用闭包时需要注意的一个问题是，如果外部函数的变量时不断变化的，那么闭包调用这个外部变量时，只能取得外部变量最后的值。

为了避免这个问题，可以在闭包内创建创建这个外部变量的副本，以此来保存外部变量变化前的值。

### 关于this对象

我们知道this对象是基于函数的执行环境绑定的，但是使用闭包时，假如我们返回一个匿名函数，那么这个函数的执行环境就不再是外部函数的执行环境，由于这个环境绑定比较难以识别，所以所有闭包的this对象执行环境都绑定在全局变量，所以在闭包中使用this获取的就是全局对象的属性。

避免这个问题同样是采用局部变量的方式，在闭包内创建一个外部执行环境的引用类型对象，这样就可以通过这个对象来调用this对象。

### 内存泄露

我们之前说过有不同的垃圾收集例程，所以在闭包中如果引用了使用引用计数方式进行垃圾收集的对象，就会导致该对象无法回收，但是我们不再使用这个对象了，也就造成了内存泄漏，需要手动将该引用解除。

## 模仿块级作用域

我们之前说过JavaScript没有块级作用域，所以在if和for循环中创建的临时变量都会变成当前执行环境的变量，重复定义变量JavaScript并不会引起报错，而是会忽视这次定义，这就导致我们在使用这个重新定义的变量是有值的。

我们又知道函数中的变量在函数执行后会被释放，因此我们可以基于函数进行模仿块级作用域。

```
(funciotn() {
 //块级作用域
})()
```

墙面的一个括号是一个匿名函数，后面跟一个括号表示立即调用这个函数，调用这个函数后，函数中的变量就会被自动销毁，这种方式在JavaScript代码中很常见

> 如果在前面不加括号，会引起JavaScript解释器出错，因为函数声明后不能有括号

## 私有变量

JavaScript中其实并没有私有变量，所有的属性和方法都是公有的。但是在函数中定义的变量可以认为是私有变量，原因在前面已经说过，因为在函数外部不能访问这些变量。

又知道闭包可以访问外部函数的所有活动变量，所以我们就可以通过在函数创建闭包的方式，将函数中的变量变成私有变量。

但是这种方式我们知道，所有的变量和方法都是实例变量，不会共享，所以就可以创建静态私有变量

### 静态私有变量

前面已经说过，原型是可以用来实现共享的，所以我们可以将共享的方法放到原型中。但是这种方式也将我们的变量变成了共享的，所以最终使用实例变量，还是静态私有变量，需要视需求而定

> 每多查找作用域链中的一个层次，就会在一定程度上影响查找速度。所以使用闭包多少会比私有变量会慢一些。

### 模块模式

通过为单例对象创建私有变量和公有方法就是所谓的模块模式，每一个单例就是一个模块，但是这种单例实际上是基于一种主动不使用的方式来创建的，是一种约定成俗的使用方式。

通过对单例对象增加私有变量以及公有方法，让外部程序只能访问其公有方法，当必须创建一个对象并以某些数据进行初始化，同时还要公开一些能够访问这些私有数据的方法，就可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量表示它。每个单例都是作为全局对象粗壮乃，不需要将它传递给其他函数。

### 增强的模块模式

进一步的增强模块模式就是适合那些单例必须是某种类型的实例，还必须添加某些属性和方法对实例进行增强的情况。

## 小结

JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式无须对函数命名，可以实现动态变成。匿名函数，也叫做lamda函数。函数表达式有以下特点：

- 函数表达式不需要名字，没有名字的函数表达式也叫做匿名函数
- 在无法确定引用函数的情况下，递归变得复杂
- 递归函数可以通过argument.cellee来调用自身，需用函数名

在函数内部定义其他函数就创建了闭包，闭包可以访问外部函数的所有变量，原理如下：

- 在后台执行环境中，闭包包含它自己的作用域，外部函数的作用域，全局作用域
- 函数自己的作用域及其变量会在函数执行后被销毁
- 当函数返回一个闭包时，函数的作用域会持续到这个闭包不存在

闭包可以用于在对象中创建私有变量

- 即使JavaScript中没有正式的私有属性概念，但是可以使用闭包来提供公有方法，可以访问作用域中包含的变量。
- 有权访问私有变量的公有方法叫做特权方法
- 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强模块模式来实现单例的特权方法。

JavaScript中的函数表达式和闭包都时及其有用的特性，利用它们可以实现很多功能。但是因为创建闭包必须维护额外的作用域，因此可能会占用大量内存。