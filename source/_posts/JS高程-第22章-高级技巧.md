---
title: JS高程 第22章 高级技巧
date: 2017-11-12 23:24:36
tags: [读书笔记, JavaScript高级程序设计]
---
> JavaScript是一种及其灵活的语言，具有多种使用风格。一般来说，编写JavaScript要么使用过程方式，要么使用面向对象方式。然而，由于它天生的动态属性，这种语言还嫩供食用更为复杂和有趣的模式。这些技巧要利用ECMAScript的语言特点、BOM扩展和DOM功能来获得强大的效果。

## 高级函数

函数的本质十分简单和过程化，但是也可以非常复杂和动态。一些额外的功能可以通过使用闭包来实现。此外，由于所有的函数都是对象，所以使用函数指针非常简单。

### 安全的类型检测

JavaScript内置的类型检测机制并非完全可靠，由于一些无法预知的行为，经常会导致检测数据类型得到不靠谱的结果。解决这个问题的办法是：通过调用Object原生的toString方法，该方法返回一个[object NativeConstructorName] 格式的字符串。每个类在内部都有一个[[Class]]属性，这个属性中就指定了上述字符串中的构造函数名。

### 作用域安全的构造函数

构造函数实际上就是一个使用new操作符调用的函数。当使用new调用时，构造函数内用到的this对象会指向新创建的对象实例。这就导致了，当在没有使用new操作符调用该构造函数时，会将this绑定到全局对象上，导致错误对象属性的以为增加。避免这个问题的方式是，在进行任何改变前，首先确认this对象是正确类型的实例。如果不是，那么创建新的实例并返回。

### 惰性载入函数

因为浏览器之间行为的差异，多数JavaScirpt代码包含了大象的if语句。大量的进行if判断必然导致程序运行缓慢。解决这个问题的方案称之为惰性载入技巧，表示函数执行的分支只会发生一次。这里有两种实现惰性载入的方式。

1. 在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再筋骨过执行的分支了。
2. 在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损失性能，而在代码首次加载时损失一点性能。

### 函数绑定

函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递的同时保留代码执行环境。

### 函数柯里化

与函数绑定紧密相关的主题是函数柯里化(function currying)，它用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数。

## 防篡改对象

JavaScript共享的本质一直是开发人员心头的同。因为任何对象都可以被在同一环境中运行的代码修改。开发人员很可能会意外地修改别人的代码，甚至更糟糕地，用不兼容的功能重写原生对象。ECMAScript5致力于解决这个问题，可以让开发人员定义防篡改对象。

> 一旦把对象定义为防篡改，就无法撤销了。

### 不可扩展对象

默认情况下，所有的对象都是可以扩展。也就是说，任何时候都可以向对象中添加属性和方法。使用Object.prevetExtensions可以改变这个行为，让你不能再给对象添加属性和方法。在调用了这个方法之后，就不能给对象添加新属性和方法了。在非严格模式下，给对象添加新成员会导致静默失败，而在严格模式下，尝试不可扩展的对象添加新成员会导致抛出错误。

另外，虽然不能给对象添加新成员，但已有的成员则丝毫不受影响。仍然还可以修改和删除已有的成员。

### 密封的对象

ECMAScript 5为对象定义的第二个保护级别是密封对象。密封对象不可扩展，而且已有成员的[[Configurable]]特性将被设置为false。要密封对象，可以使用Object.seal方法。

在非严格模式下，尝试添加和删除密封对象的行为被静默忽略了。在严格模式下，这种行为都会导致抛出错误。

### 冻结的对象

最严格的放篡改级别是冻结对象。冻结的对象既不可扩展，又是密封的，而且对象数据属性[[Writable]]特性设置为false。可以使用Object.freeze方法来冻结对象。

## 高级定时器

因为JavaScript是单线程的运行环境，因此定时器仅仅只是计划代码在未来的某个时间执行，执行时机是不能保证的。

### 重复的定时器

使用setInterval创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。通过JavaScript引擎的优化，可以避免这个问题。当使用setInterval时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。

### Yielding Processes

运行在浏览器中JavaScriptJavaScript都被分配了一个确定数量的资源。以防止恶意的Web程序员把用于的计算机搞挂了。其中一个限制是长时间运行脚本的制约，如果代码运行超过特定的事件或者特定语句数量就不让它继续执行。因此为了比避免这个问题。可以使用定时器分割这类循环操作。这是一种叫做数组分块的技术，小块小块地处理数组，通常每次一小块。基本思路是为要处理的项目创建一个队列，然后使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。

### 函数节流

浏览器中某些计算和处理要比其他的昂贵很多。为了绕开这个问题，可以使用定时器对该函数进行节流。函数节流背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清楚前一次的定时器并创建另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。

## 自定义事件

事件是JavaScript与浏览器交互的主要途径。事件的本质就是观察者模式，因此可以通过自己实现观察者模式来实现自定义事件。

## 拖放

拖放是一种非常流行的用户界面模式。它的概念很简单：点击某个对象，并按住鼠标按钮不妨，将鼠标移动到另一个区域，然后释放鼠标按钮将对象放在这里。拖放功能也流行到Web上，成为了一些更创痛的配置界面的一种候选方案。

拖放的基本概念很简单：创建一个绝对定位的元素，可以使用鼠标易懂。这个技术源自一种叫做鼠标拖尾的经典网页技巧。鼠标拖尾是一个或者多个图片在页面上跟着鼠标指针易懂。但元素鼠标拖尾的基本代码需要为文档设置一个onmousemove事件处理程序，它总是将指定元素移动到鼠标指针的位置。

## 小结

JavaScript中的函数非常强大，因为他们是第一类对象。使用必报和函数环境切换，还可以有很多使用函数的强大方法。可以创建作用域安全的构造函数，确保在缺少new操作符时调用构造函数不会改变错误的环境对象。
