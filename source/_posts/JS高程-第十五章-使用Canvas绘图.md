---
title: JS高程 第十五章 使用Canvas绘图
date: 2017-11-05 21:39:25
tags: [读书笔记, JavaScript高级程序设计]
---
> 不用说，H5添加的最受欢迎的功能就是canvas元素。这个元素负责在页面中设定一个区域，然后就可以通过JavaScript动态地在这个区域绘制图像。canvas元素最早是由苹果公司推出，很快H5加入了这个元素，主流浏览器也迅速的开始支持它。与浏览器环境的其他组件类似，cancas由几组API构成，但并非所有浏览器都支持所有这些API，除了剧本基本绘图能力的2D上下文，canvas还建议了一个名为WebGL的3D上下文。目前所有支持该元素的浏览器都支持2D上下文，但是对WebGl的支持还不够好。

<!--more-->

## 基本用法

要使用canvas元素，必须先设置其width和height属性，指定款恶意绘图的区域大小。出现在开始喝结束标签中的内容是后背信息，如果浏览器不支持canvas元素，就会显示这些信息。

使用canvas元素之前，需要检测绘图上下文对象是否存在，也就是getContext方法是否存在。使用toDataUrl可以导出canvas元素上绘制图像。这个方法接受一个参数，即图像的MIME类型，而且适合于创建图像的任何上下文。

## 2D上下文

使用2D绘图上下文提供的方法，可以绘制简单的2D图形，比如矩形、弧线和路径。2D上下文的坐标开始于canvas元素的左上角，原点坐标是(0,0)。所有的坐标值都基于这个原点计算，x值越大表示越靠右，y值越大表示越靠下。默认情况下width和height表示水平和垂直方向上可用的像素数目。

### 填充和描边

2D上下文的两种基本绘图操作是填充和描边。填充，就是用指定的样式(颜色、渐变或图像)填充图形；描边，就是只在图形的边缘画线。大多数2D上下文操作都会细分为填充和描边两个操作，而操作的结果取决于两个属性：fillStyle和strokeStyle。这两个属性的值可以是字符串、渐变对象或模式对象，如果为它们指定表示颜色的字符串，可以使用CSS中指定颜色的任何格式：颜色名、十六进制码、rgb、rgba、hsl或hsla。

### 绘制矩形

矩形是唯一一种可以直接在2D上下文中绘制的形状。与矩形有关的方法包括fillRect()、strokeRect()和clearReact()。这三个方法都接受4个参数：矩形的x坐标、矩形的y坐标、矩形宽度和举行高度。这些参数的单位都是像素。

### 绘制路径

2D绘制上下文支持很多在画布上绘制路径的方法。通过路径可以创造出复杂的形状和线条。要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新路径。然后，再通过调用下列方法来实际地绘制路径。

- arc(x, y, radius, startAngle, endAngle, counterclockwise): 以(x, y)为圆心绘制一条弧线，弧线半径为radius，起始和结束角度(用弧度表示)分别为startAngle和endAngle。最后一个参数表示startAngle和endAngle是否按照逆时针防线计算，值为false表示按照顺时针方向计算。
- arcTo(x1, y1, x2, y2, radius): 从上一点开始绘制一条弧线，到(x2, y2)为止，并且以给定的半径radius穿过(x1, y1)。
- bezierCurveTo(c1x, c1y, c2x, c2y, x, y): 从上一点开始绘制一条曲线，到(x, y)为止，并且以(c1x, c1y)和(c2x, c2y)作为控制点。
- lineTo(x, y): 从上一点开始绘制一条直线，到(x, y)为止。
- moveTo(x, y): 将绘制游标移动到(x, y)，不画线。
- quadraticCurveTo(cx, cy, x, y): 从上一点开始绘制一条二次曲线，到(x, y)为止，并且以(cx, cy)作为控制点。
- rect(x, y, width, height): 从点(x, y)开始绘制一个矩形， 宽度和高度分别由width和height指定。这个方法绘制的是矩形路径，而不是strokeRect()和fillRect()所绘制的独立的形状。

创建了路径后，接下来有几种可能的选择。如果想绘制一条连接到路径起点的线条，可以调用closePath。如果路径已经完成，你想用fillStyle填充它，可以调用fill()方法。另外，还可以调用stroke方法对路径描边，描边使用的是strokeStyle。最后还可以调用clip()，这个方法可以在路径上创建一个剪切区域。

### 绘制文本

文本与图形总是如影随形。为此，2D绘图上下文也提供了绘制文本的方法。绘制文本主要有两个方法: fillText()和strokeText()。这两个方法都可以接收4个参数：要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。而且，这两个方法都以下列3个属性为基础：

- font: 表示文本样式、大小及字体，用CSS中指定字体的格式来指定。
- textAlign: 表示文本对齐方式。可能的值由start,end,left,right和center。
- textBaseline: 表示文本的基线。可能的值有top,hanging,middle,alphabetic,ideographic,bottom。

这几个属性都有默认值，因此没有必要每次使用它们都重新设置一遍值。

### 变换

通过上下文的变换，可以把处理后的图像绘制到画布上。2D绘制上下文支持各种基本的绘制变换。创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有处理都按描述直接绘制。为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。

可以通过如下方法来修改变换矩阵。

- rotate(angle): 围绕原点旋转图像angle弧度。
- scale(scaleX, scaleY): 缩放图像，在x方向乘以scaleX，在y方向乘以scaleY。scaleX和scaleY的默认值都是1.0。
- translate(x, y): 将坐标原点移动到(x, y)。执行这个变换后，坐标(0, 0)会变成之前由(x, y)表示的点。
- transform(m1_1, m1_2, m2_1, m2_2, dx, dy): 直接修改变换矩阵，方式是乘以矩阵。
- setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy): 将变换矩阵重置为默认状态，然后再调用transform。

### 绘制图像

2D绘图上下文内置了对图像的支持。如果你想把一幅图像绘制到画布上，可以使用drawImage()方法。根据期望的最终结果不同，调用这个方法时，可以使用三种不同的参数组合。最简单的调用方式是传入一个HTML&lt;img&gt;元素，以及绘制该图像x和y坐标。

除了个drawImage方法传入HTML&lt;img&gt;元素外，还可以传入另一个canvas元素作为其第一个参数。这样，就可以把另一个画布内容绘制到当前画布。

结合使用drawImage和其他方法，可以对图像进行各种基本操作。而操作的结果可以通过toDataURL方法获得。不过，有一个例外，即图像不能来自其他域，调用toDataURL会抛出一个错误。

### 阴影

2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。

- shadowColor: 用CSS颜色格式表示的阴影颜色，默认黑色。
- shadowOffsetX: 形状或路径x轴方向的阴影偏移量，默认为0.
- shadowOffsetY: 形状或路径y轴方向的阴影偏移量，默认为0.
- shadowBlur: 模糊的像素数，默认为0，即不模糊。

### 渐变

渐变由CanvasGradient实例表示，很容易通过2D上下文来创建和修改。要创建一个新的线性渐变，可以通过调用createLinearGradient方法。这个方法接受4个参数：起点的x坐标、起点的y坐标、终点的x坐标、终点的y坐标。调用这个方法后，它就会创建一个指定大小的渐变，并返回CanvasGradient对象的实例。

### 模式

模式其实就是重复的图像，可以用来填充或描边图形。要创建一个新模式，可以调用createPattern方法并传入两个参数: 一个HTML&lt;img&gt;元素和一个表示如何重复图像的字符串。其中第二个参数的值与CSS的background-repeat属性值相同,包括repeat, repeat-x, repeat-y和no-repeat。

### 使用图像数据

2D上下文的一个明显的长处就是，可以通过getImageData取得原始图像数据。这个方法接收4个参数：要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度。

### 合成

还有两个会应用2D上下文中国年所有绘制操作的属性：globalAlpha和globalCompositionOperation。其中，globalAlpha是一个介于0和1之间的值，用于指定所有绘制的透明度。默认值为0.如果所有后续操作都要基于相同的透明度，就可以先把globalAlpha设置为适当值，然后绘制，最后再把它设置回默认值0.

globalCompositionOperation表示后绘制的图形怎样与先绘制的图形结合。这个属性值是字符串，可能的值如下：

- source-over(默认值): 后绘制的图形位于先绘制的图形上方。
- source-in: 后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分透明。
- source-out: 后绘制的图形和先绘制图形不重叠的部分可见，先绘制的图形完全透明。
- source-atop: 后绘制的图形与先绘制的图形重叠部分可见，先绘制图形不受影响。
- destination-over: 后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。
- destination-in: 后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。
- destination-out: 后绘制的图形擦除与先绘制的图形重叠的部分。
- destination-atop: 后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的图形会变透明。
- lighter: 后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮。
- copy: 后绘制的图形完全替代与之重叠的先绘制图形。
- xor: 后绘制的图形与先绘制的图形重叠的部分执行异或操作。

## WebGL

WebGL是针对Canvas的3D上下文。与其他Web技术不同，WebGL并不是W3C制定的标准，而是由khronosGroup制定的。Khronos Group也设计了其他图形处理API，比如OpenGL ES 2.0。浏览器中使用的WebGL就是给予OpenGl ES 2.0制定的。

Firefox 4+ 和Chrome都实现了WebGL API。Safari 5.1也实现了WebGL，但默认是禁用的。WebGL比较特别的地方在于，某个浏览器的某个版本实现了它，并不一定意味着就真能使用它。某个浏览器支持WebGL，至少以为着两件事： 首先，浏览器本身必须实现WebGL API；其次，计算机必须升级显示驱动程序。鱼腥Windows XP等操作系统的一些老机器，其驱动程序一般都不是最新的。因此，这些计算机的浏览器都会禁用WebGL。从稳妥的角度考虑，在使用WebGL之前，最好检测其是否得到了支持，而不是只检测特定的浏览器版本。

## 小结

H5的canvas元素提供了一组JavaScript API，让我们可以动态地创建图形和图像。图形是在一个特定的上下文中创建的，而上下文对象目前有两种。第一种是2D上下文，可以执行原始的绘图操作，比如：

- 设置填充、描边颜色和模式
- 绘制矩形
- 绘制路径
- 绘制文本
- 创建渐变和模式

第二种是3D上下文，即WebGL上下文。WebGL是从OpenGL ES 2.0 移植到浏览器中的，而OpenGL ES 2.0是游戏开发人员在创建计算机图形图像时经常使用的一种语言。WebGL支持2D上下文更丰富和更强大的图形图像处理能力。

目前，主流浏览器的较新版本大都已经支持canvas标签。同样地，这些版本的浏览器基本上也都支持2D上下文。但是对于WebGL而言，目前还只有Firefox 4+ 和Chrome支持它。没有做过实践，应该至少作者在写这篇文章时还是这个情况。