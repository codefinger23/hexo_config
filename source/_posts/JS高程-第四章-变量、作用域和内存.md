---
title: JS高程 第四章 变量、作用域和内存
date: 2017-10-19 22:09:12
tags: 读书笔记
---
## 基本类型和引用类型的值

基本类型指的是undefined, null, boolean, number, string 这5种基本的类型，他们的值是通过变量名直接访问内存空间，与传统语言的差别不大。基本类型是按值访问的，因为可以直接操作保存在内存中的数据。

引用类型Object的值，是保存在内存空间的对象，可能由多种数据聚合，由于JavaScript不允许直接访问内存数据，所以必须通过引用进行操作，因为是在操作对象的引用，而不是实际对象的值，所以引用类型是按引用访问的。

> 有些语言比如C++，字符串是以对象的形式表示的String，因此也是引用类型。但在ECMAScript中不是这样的。

### 动态的属性

- 引用类型可以动态的改变和删除属性和方法，如果对象不被删除，增加的属性和方法将一直存在。
- 基本类型也可以添加属性，这种操作不会导致错误，但是会被解析器自动忽略。

### 复制变量的值

- 基本类型的复制是内存空间的复制，对复制出来的变量进行修改不会影响原值
- 引用类型的复制只是复制了该引用，不会复制内存，相当于变量别名，对复制出来的引用变量进行修改，将会导致实际内存数据的修改

### 传递参数

ECMAScript中的所有函数都是按值传递的

- 对于基本类型来说，相当于在函数内部对该类型做了一次复制，产生相当于局部变量的效果。
- 对于引用类型来说，传递的是其引用的值，也是对引用类型的复制，在函数内部对引用数据进行修改，将会导致原始数据修改。
- 如果在函数内部将传递过来的引用类型指向函数内部对象，则形成类似与局部变量的效果，将在函数执行后销毁。

### 检测类型

- 对于基本类型的检测采用操作符typeof，可以确定一个类型是哪种基本类型或者是引用类型
- 对于引用类型，可以使用操作符instanceof确定变量是否是一个指定引用类型的实例，使用范式variable instanceof constructor，返回值是逻辑真假。
- 使用typeof检测函数时返回值是"function"，在ECMAScript-262中规定，任何在内部实现[[Call]]方法的对象，都应该在应用typeof操作符时返回"function"，但是有些浏览器没有实现，特别是在检测正则表达式的时候，需要确认一下。

## 执行环境与作用域

执行环境是JavaScript最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

全局执行环境是最外围的执行环境。根据ECMAScript实现所在的宿主机环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量与函数，都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中所有的变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。

当代码在一个环境执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象，这个对象在全局环境是不存在的。作用域链中的下一个变量对象来自包含环境，即外部环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

标识符的解析是沿着作用域链一级一级的搜索标识符的出现。搜索过程始终从作用域链前端开始，然后逐级地向后回溯，直至找到标识符为止，如果找不到标识符，通常会导致错误。

### 延长作用域链
 
 虽然执行环境的类型只有两种——全局和局部，但有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。当执行流进入下列任何一个语句时，作用域链就会得到加长：
 
 - try-catch 语句的catch块
 - with 语句
 
### 没有块级作用域

在类C语言中，花括号封闭的代码块都有自己的作用域，在ECMAScript中就是自己的执行环境，但是在JavaScript中，这种变量会被添加到当前的执行环境，并与当前环境共存亡。

#### 声明变量

使用var声明的变量会自动被添加到最接近的环境中。在函数内部最接近的执行环境就是函数环境

#### 查询标识符

这就是局部变量覆盖全局变量的地方，因为是一级一级的查找，查找到之后就会退出查找。

## 垃圾收集

JavaScript 具有自动垃圾收集机制，也就是，执行环境会负责管理代码执行过程中使用的内存。而在C和C++中，需要手工追踪内存。这种垃圾手机机制的原理其实很简单，找出那些不再使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔或代码中预定的执行时间，周期性的执行这一操作。

对于局部变量来说，局部环境销毁，这些变量所占的内存机会被回收，对于非局部变量，就需要标记不再使用的变量，用于将来回收该变量的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中，通常有两种策略。

### 标记清除

JavaScript最常用的垃圾收集方式是标记清除。当变量进入环境，例如在函数中声明一个变量。就将变量标记为进入环境。从逻辑上来讲，进入环境的变量永远不能被释放，当变量离开环境，就将变量标记为离开环境。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，最后垃圾收集齐完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 引用计数

引用计数是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给变量时，这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值引用次数+1。反之则-1。垃圾收集器可以回收引用次数为零的值所占的内存空间。

但是这种引用计数存在一个交叉引用的问题，这回导致两个变量和值永远无法释放，所以目前很少有使用这种方式进行垃圾回收的策略。如果确认是使用引用计数方式进行垃圾回收，可以通过手动解锁来避免这个问题。

### 性能问题

垃圾收集器是周期运行的，如果需要回收的内存很多，则回收工作量也很大，IE浏览器因此声名狼藉的性能问题，是因为IE的垃圾收集器是根据内存分配量来进行的，具体一点就是当脚本中包含256个变量、4096个对象或数组和数组元素或64KB的字符串，达到上述任意临界值，都会导致垃圾收集器的运行，如果一个脚本中一直保持在临界值范围，那么垃圾收集器将会频繁进行，导致严重的性能问题。

随着IE7的发布，其JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、对象、元素的临界值被调整为动态修正。IE7中的各项临界值初识时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，那么临界值将会加倍。如果例程回收85%的内存分配，那么临界值将会重置。

> 在IE中，可以通过window.CollectGarbage()方法立即执行垃圾收集。

### 管理内存

因为浏览器得到系统内存比桌面应用要少得多，这是为了避免在浏览网页过程中因为内存不足导致系统崩溃，因此在编写JavaScript脚本时也需要注意优化内存占用。使用对象之后，通过解除引用方式就是很好的习惯，解除引用不意味着自动回收该值所占用的内存空间，而是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

## 小结

JavaScript的内存管理相对简单，也比较容易理解

- 基本类型值在内存中占用固定大小
- 基本类型的复制将会产生内存的复制，修改副本不会修改原值
- 引用类型的复制不会复制内存，修改副本会修改指向的内存空间
- 确定基本类型的值可以使用typeof，引用类型使用instanceof

JavaScript通过作用域链存储变量，实质上就是可遍历的栈

- 执行环境有全局和局部之分
- 每次进入新的执行环境，就会创建用于搜索的作用域链
- 函数可以访问所有父环境的变量
- 父环境不能访问子环境的变量

垃圾回收是性能优化的重点

- 离开作用域的值被自动标记为可回收
- 标记清除是主流的垃圾收集算法
- 引用计数会导致交叉引用或叫做循环引用导致无法释放内存
- 解除引用可以很好的管理内存

